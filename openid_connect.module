<?php

/**
 * @file
 * A pluggable client implementation for the OpenID Connect protocol.
 * 
 * Authentication Flow:
 * 1. Initial Authorization Request
 *    - User clicks login button
 *    - authorize() method constructs authorization URL
 *    - User is redirected to provider's authorization endpoint
 * 
 * 2. Token Exchange
 *    - Provider redirects back to our redirect page
 *    - retrieveTokens() exchanges authorization code for tokens
 *    - ID token is validated and claims are extracted
 * 
 * 3. User Authentication
 *    - User info is retrieved from userinfo endpoint
 *    - User is either logged in or registered
 *    - User session is established
 */

// phpcs:disable Backdrop.Commenting.FunctionComment.TypeHintMissing



/**
 * Base path where to login providers can redirect in the OAuth2 flow.
 */
define('OPENID_CONNECT_REDIRECT_PATH_BASE', 'openid-connect');

/**
 * Implements hook_menu().
 * 
 * Defines routes for:
 * - Admin configuration
 * - OAuth redirect handler (critical for authentication flow)
 * - User account connection management
 */
function openid_connect_menu() {
  $items = array();
  $items['admin/config/services/openid-connect'] = array(
    'title' => 'OpenID Connect',
    'description' => 'Configure OpenID Connect, choose active OpenID Connect clients etc.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('openid_connect_admin_form'),
    'access arguments' => array('configure openid connect clients'),
    'file' => 'includes/openid_connect.admin.inc',
  );
  $items['openid-connect/%'] = array(
    'title' => 'OpenID Connect redirect page',
    'page callback' => 'openid_connect_redirect_page',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'includes/openid_connect.pages.inc',
  );
  $items['user/%user/connected-accounts'] = array(
    'title' => 'Connected accounts',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('openid_connect_connect_form', 1),
    'access callback' => 'openid_connect_connected_accounts_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
    'file' => 'includes/openid_connect.forms.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function openid_connect_permission() {
  return array(
    'configure openid connect clients' => array(
      'title' => t('Configure OpenID Connect clients'),
    ),
    'manage own openid_connect accounts' => array(
      'title' => t('Manage own connected accounts'),
    ),
    'openid_connect set own password' => array(
      'title' => t('Set a password for local authentication'),
      'description' => t('If the account is connected with an external provider, the user needs this permission in order to set their own password.'),
    ),
  );
}

/**
 * Implements hook_config_info().
 */
function openid_connect_config_info() {
  $prefixes['openid_connect.settings'] = array(
    'label' => t('OpenID Connect settings'),
    'group' => t('Configuration'),
  );
  return $prefixes;
}

/**
 * Returns a client instance.
 *
 * @param string $client_name
 *   The name of the client to instantiate.
 *
 * @return OpenIDConnectClientInterface
 *   Client instance.
 * 
 * This is a critical function in the authentication flow as it:
 * 1. Loads the appropriate client plugin
 * 2. Retrieves client configuration
 * 3. Creates an instance of the client class
 */
function openid_connect_get_client($client_name) {
  $clients = backdrop_static(__FUNCTION__);
  if (!isset($clients[$client_name])) {
    $plugin = openid_connect_get_plugin($client_name);
    if ($plugin) {
      $settings = config_get('openid_connect.settings', 'openid_connect_client_' . $client_name);
      // Ensure settings is an array, even if the configuration is empty.
      $settings = is_array($settings) ? $settings : array();
      $clients[$client_name] = new $plugin['class']($client_name, $plugin['title'], $settings);
    }
    else {
      $clients[$client_name] = FALSE;
    }
  }

  return $clients[$client_name];
}

/**
 * Returns an OpenID Connect client plugin.
 *
 * @param string $client_name
 *   Name of the plugin.
 *
 * @return array
 *   An array with information about the requested operation type plugin.
 */
function openid_connect_get_plugin($client_name) {
  $plugins = openid_connect_get_plugins();
  return isset($plugins[$client_name]) ? $plugins[$client_name] : NULL;
}

/**
 * Returns the available OpenID Connect client plugins.
 *
 * @param bool $enabled_only
 *   Whether to return only the plugins enabled by the administrator.
 * 
 * This function:
 * 1. Discovers available client plugins
 * 2. Filters based on enabled status if requested
 * 3. Returns plugin definitions for client instantiation
 */
function openid_connect_get_plugins($enabled_only = FALSE) {
  $plugins = &backdrop_static(__FUNCTION__);
  
  if (!isset($plugins)) {
    $plugins = array();
    $config = config('openid_connect.settings');
    $clients_enabled = $config->get('openid_connect_clients_enabled') ?: array();
    
    // Look for client plugins in the plugins directory
    $plugin_path = backdrop_get_path('module', 'openid_connect') . '/plugins/openid_connect_client';
    if (is_dir($plugin_path)) {
      $dirs = scandir($plugin_path);
      foreach ($dirs as $dir) {
        if ($dir[0] != '.' && is_dir($plugin_path . '/' . $dir)) {
          $client_name = $dir;
          $class_name = 'OpenIDConnectClient' . backdrop_ucfirst($client_name);
          
          // Check for class file
          if (file_exists($plugin_path . '/' . $client_name . '/' . $class_name . '.class.php')) {
            $plugins[$client_name] = array(
              'name' => $client_name,
              'title' => backdrop_ucfirst($client_name),
              'class' => $class_name,
            );
          }
        }
      }
    }
  }
  
  // Filter plugins based on enabled status if requested
  if ($enabled_only) {
    $config = config('openid_connect.settings');
    $clients_enabled = $config->get('openid_connect_clients_enabled') ?: array();
    
    foreach ($plugins as $client_name => $plugin) {
      if (empty($clients_enabled[$client_name])) {
        unset($plugins[$client_name]);
      }
    }
  }
  
  return $plugins;
}

/**
 * Implements hook_block_info().
 * 
 * Provides the login block that initiates the authentication flow.
 */
function openid_connect_block_info() {
  return array(
    'openid_connect_login' => array(
      'info' => t('OpenID Connect login'),
      'cache' => BACKDROP_CACHE_PER_ROLE | BACKDROP_CACHE_PER_PAGE,
    ),
  );
}

/**
 * Implements hook_block_view().
 * 
 * Renders the login form that starts the authentication process.
 */
function openid_connect_block_view($delta = '') {
  if ($delta == 'openid_connect_login' && user_is_anonymous()) {
    module_load_include('inc', 'openid_connect', 'includes/openid_connect.forms');

    return array(
      'subject' => t('Log in'),
      'content' => backdrop_get_form('openid_connect_login_form'),
    );
  }
}

/**
 * Creates a state token and stores it in the session for later validation.
 *
 * @return string
 *   A state token that later can be validated to prevent request forgery.
 */
function openid_connect_create_state_token() {
  // Ensure we have an active session
  if (!backdrop_session_started()) {
    backdrop_session_start();
    watchdog('openid_connect', 'Started new session for state token creation', array(), WATCHDOG_DEBUG);
  }

  $state = backdrop_random_key();
  $_SESSION['openid_connect_state'] = $state;
  $_SESSION['openid_connect_state_time'] = REQUEST_TIME;

  watchdog('openid_connect', 'Created state token: %state, Session ID: %sid', 
    array(
      '%state' => $state,
      '%sid' => session_id()
    ), WATCHDOG_DEBUG);

  return $state;
}

/**
 * Confirms anti-forgery state token.
 *
 * @param string $state_token
 *   The state token that is used for validation.
 *
 * @return bool
 *   Whether the state token matches the previously created one that is stored
 *   in the session.
 */
function openid_connect_confirm_state_token($state_token) {
  if (!backdrop_session_started()) {
    backdrop_session_start();
    watchdog('openid_connect', 'Started new session for state token validation', array(), WATCHDOG_DEBUG);
  }

  watchdog('openid_connect', 'Validating state token. Received: %received, Session: %session', 
    array(
      '%received' => $state_token,
      '%session' => print_r($_SESSION, TRUE)
    ), WATCHDOG_DEBUG);

  if (empty($_SESSION['openid_connect_state'])) {
    watchdog('openid_connect', 'No state token in session. Session ID: %sid', 
      array('%sid' => session_id()), WATCHDOG_ERROR);
    return FALSE;
  }

  // Validate state token
  $valid = $state_token === $_SESSION['openid_connect_state'];
  
  // Check if state token is not too old (max 30 minutes)
  if ($valid && !empty($_SESSION['openid_connect_state_time'])) {
    $valid = ($_SESSION['openid_connect_state_time'] > (REQUEST_TIME - 1800));
    if (!$valid) {
      watchdog('openid_connect', 'State token expired. Created: %time', 
        array('%time' => date('Y-m-d H:i:s', $_SESSION['openid_connect_state_time'])), WATCHDOG_ERROR);
    }
  }

  if (!$valid) {
    watchdog('openid_connect', 'State token mismatch. Expected: %expected, Received: %received', 
      array(
        '%expected' => $_SESSION['openid_connect_state'],
        '%received' => $state_token
      ), WATCHDOG_ERROR);
  } else {
    watchdog('openid_connect', 'State token validated successfully', array(), WATCHDOG_DEBUG);
  }

  // Clear state data after validation
  unset($_SESSION['openid_connect_state']);
  unset($_SESSION['openid_connect_state_time']);

  return $valid;
}

/**
 * Access callback: Connected accounts page.
 */
function openid_connect_connected_accounts_access($account) {
  global $user;
  if (user_access('administer users')) {
    return TRUE;
  }

  return $user->uid && $user->uid === $account->uid && user_access('manage own openid_connect accounts');
}

/**
 * Saves user profile information into a user account.
 */
function openid_connect_save_userinfo($account, $userinfo) {
  
  watchdog('openid_connect', 'Starting to save userinfo in openid_connect_save_userinfo for user: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
  $config = config('openid_connect.settings');
  $account_wrapper = entity_metadata_wrapper('user', $account);
  $properties = $account_wrapper->getPropertyInfo();
  $properties_skip = _openid_connect_user_properties_to_skip();
    
  $userinfo_mappings = $config->get('openid_connect_userinfo_mapping_claims');

  // iterate through known properties of user, grab appropriate ones for mapping
  foreach ($properties as $property_name => $property) {
    if (isset($properties_skip[$property_name])) {
      watchdog('openid_connect', 'Skipping property: %property', array('%property' => $property_name), WATCHDOG_DEBUG);
      continue;
    }
    
    // claim will be NULL if no mapping is defined in config
    $claim = $config->get('openid_connect_userinfo_mapping_property_' . $property_name);
    watchdog('openid_connect', 'Checking property: %property, mapped claim: %claim', 
      array('%property' => $property_name, '%claim' => $claim), WATCHDOG_DEBUG);

    // map claim value into user account if it exists, otherwise continue
    if ($claim && isset($userinfo[$claim])) {
      try {
        $account_wrapper->{$property_name} = $userinfo[$claim];
      }
      catch (EntityMetadataWrapperException $e) {
        watchdog_exception('openid_connect', $e);
      }
    }
  }

  // allow CMQCC (or other modules) to alter user account
  backdrop_alter('openid_connect_save_userinfo', $account_wrapper, $userinfo);

  if (isset($userinfo['name'])) {
    $account->data['oidc_name'] = $userinfo['name'];
    watchdog('openid_connect', 'Set oidc_name: %name', array('%name' => $userinfo['name']), WATCHDOG_DEBUG);
  }

  try {
    $account_wrapper->save();
    watchdog('openid_connect', 'Successfully saved account wrapper', array(), WATCHDOG_DEBUG);
  }
  catch (Exception $e) {
    watchdog('openid_connect', 'Error saving account wrapper: @error', array('@error' => $e->getMessage()), WATCHDOG_ERROR);
  }

  if (config_get('system.performance', 'user_pictures') && $config->get('openid_connect_user_pictures') && !empty($userinfo['picture'])) {
    watchdog('openid_connect', 'Attempting to save user picture from URL: %url', array('%url' => $userinfo['picture']), WATCHDOG_DEBUG);
    openid_connect_save_user_picture($account, $userinfo['picture']);
  }
}

/**
 * Save an image as the user picture.
 *
 * @param object $account
 *   The user account.
 * @param string $picture_url
 *   The URL to a user picture.
 */
function openid_connect_save_user_picture($account, $picture_url) {
  $config = config('openid_connect.settings');
  $picture_directory = file_default_scheme() . '://' . config_get('system.performance', 'user_picture_path');
  if (!file_prepare_directory($picture_directory, FILE_CREATE_DIRECTORY)) {
    return;
  }

  $response = backdrop_http_request($picture_url);
  if ($response->code != 200) {
    watchdog('openid_connect', 'The user picture could not be fetched from URL: @url', array('@url' => $picture_url));
    return;
  }

  // Skip saving if the remote picture has not changed.


  $hash = md5($response->data);
  if (!empty($account->picture) && isset($account->data['oidc_picture_hash']) && $account->data['oidc_picture_hash'] === $hash) {
    return;
  }

  $picture_path = file_stream_wrapper_uri_normalize($picture_directory . '/picture-' . $account->uid . '-' . REQUEST_TIME . '.jpg');
  $picture_file = file_save_data($response->data, $picture_path, FILE_EXISTS_REPLACE);

  // Check to make sure the picture isn't too large for the site settings.


  // Suppress the status message that Backdrop sets after a successful resizing.


  $status_messages = isset($_SESSION['messages']['status']) ? $_SESSION['messages']['status'] : NULL;
  file_validate_image_resolution($picture_file, config_get('system.performance', 'user_picture_dimensions'));
  if (isset($status_messages)) {
    $_SESSION['messages']['status'] = $status_messages;
  }
  else {
    unset($_SESSION['messages']['status']);
  }

  // Update the user account object.


  $account->picture = $picture_file;
  $account->data['oidc_picture_hash'] = $hash;
  user_save($account);

  // Consider adding file type validation
  $file_info = getimagesizefromstring($response->data);
  if ($file_info === FALSE) {
    watchdog('openid_connect', 'Invalid image file received from URL: @url', array('@url' => $picture_url), WATCHDOG_ERROR);
    return;
  }
}

/**
 * Logs in a user.
 *
 * @param object $account
 *   The user account.
 * @param string|array &$destination
 *   The path to redirect to after login.
 */
function openid_connect_login_user($account, $destination) {
  watchdog('openid_connect', 'Starting login in openid_connect_login_user for user: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
  
  // Ensure we have a valid user account
  if (!$account->uid) {
    watchdog('openid_connect', 'Invalid account passed to login function', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  // Start session if needed
  if (!backdrop_session_started()) {
    backdrop_session_start();
    watchdog('openid_connect', 'Started new session for login', array(), WATCHDOG_DEBUG);
  }

  // Initialize the session
  $_SESSION['uid'] = $account->uid;
  $_SESSION['roles'] = array_keys($account->roles);
  $_SESSION['name'] = $account->name;
  
  watchdog('openid_connect', 'Session initialized with data: @session', array('@session' => print_r($_SESSION, TRUE)), WATCHDOG_DEBUG);

  // Set the global user object
  global $user;
  $user = $account;
  
  watchdog('openid_connect', 'Global user set to: @user', array('@user' => print_r($user, TRUE)), WATCHDOG_DEBUG);

  $form_state = array();
  $form_state['uid'] = $account->uid;
  $form = array();

  // TFA integration.
  if (module_exists('tfa')) {
    // The 'code' and 'state' parameters have now been used.
    unset($_GET['code'], $_GET['state']);

    // TFA will preserve the initial redirect if it is set in the $form_state.
    $form_state['redirect'] = $destination;

    tfa_login_submit($form, $form_state);
    tfa_login_form_redirect($form, $form_state);

    // TFA may want to change the redirect destination.
    if (isset($form_state['redirect']) && $form_state['redirect'] != 'user/' . $form_state['uid']) {
      $destination = $form_state['redirect'];
    }
  }
  else {
    // Standard login process
    watchdog('openid_connect', 'Proceeding with standard login for uid: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
    
    // Finalize the login
    user_login_finalize($form_state);
    
    // Update the user's last login time
    $account->login = REQUEST_TIME;
    user_save($account);
    
    watchdog('openid_connect', 'Login finalized for uid: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
  }

  // Verify login was successful
  if (!user_is_logged_in()) {
    watchdog('openid_connect', 'Login failed - user not logged in after finalization. Session: @session', 
      array('@session' => print_r($_SESSION, TRUE)), WATCHDOG_ERROR);
    return FALSE;
  }

  watchdog('openid_connect', 'Login successful for uid: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
  return TRUE;
}

/**
 * Saves the current path in the session, for redirecting after authorization.
 */
function openid_connect_save_destination() {
  if (!backdrop_session_started()) {
    backdrop_session_start();
  }

  $destination = &backdrop_static(__FUNCTION__);
  if (!isset($destination)) {
    $destination = backdrop_get_destination();
  }
  
  // Log the raw destination value
  watchdog('openid_connect', 'Raw destination value: @dest', 
    array('@dest' => print_r($destination, TRUE)), WATCHDOG_DEBUG);
    
  // Restructure the destination array if needed
  if (isset($destination['destination'])) {
    $path = $destination['destination'];
    // If destination itself is a query string, parse it
    if (strpos($path, '?') !== FALSE) {
      $parts = backdrop_parse_url($path);
      $path = $parts['path'];
      $query = isset($parts['query']) ? backdrop_get_query_array($parts['query']) : array();
    } else {
      $query = array();
    }
    $destination = array(
      'path' => $path,
      'query' => $query,
    );
    watchdog('openid_connect', 'Restructured destination: @dest', 
      array('@dest' => print_r($destination, TRUE)), WATCHDOG_DEBUG);
  }
  
  // Log the current path and query
  watchdog('openid_connect', 'Current path: %path, Query: %query', 
    array(
      '%path' => current_path(),
      '%query' => print_r($_GET, TRUE)
    ), WATCHDOG_DEBUG);
  
  // Log the session state
  watchdog('openid_connect', 'Session state before saving destination: @session', 
    array('@session' => print_r($_SESSION, TRUE)), WATCHDOG_DEBUG);
  
  $_SESSION['openid_connect_destination'] = $destination;
  
  // Log the saved destination
  watchdog('openid_connect', 'Saved destination in session: @dest', 
    array('@dest' => print_r($_SESSION['openid_connect_destination'], TRUE)), WATCHDOG_DEBUG);
}

/**
 * Creates a user indicating sub-id and login provider.
 *
 * @param string $sub
 *   The subject identifier.
 * @param array $userinfo
 *   The user claims, containing at least 'email'.
 * @param string $client_name
 *   The machine name of the client.
 *
 * @return object|false
 *   The user object or FALSE on failure.
 */
function openid_connect_create_user($sub, $userinfo, $client_name) {
  watchdog('openid_connect', 'Starting user creation process for sub: %sub', array('%sub' => $sub), WATCHDOG_DEBUG);
  
  // Validate required information
  if (empty($userinfo['email'])) {
    watchdog('openid_connect', 'Cannot create user - missing email', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  try {
    // Check if user with this email already exists
    $existing_user = user_load_by_mail($userinfo['email']);
    if ($existing_user) {
      watchdog('openid_connect', 'User with email %email already exists (uid: %uid)', 
        array('%email' => $userinfo['email'], '%uid' => $existing_user->uid), WATCHDOG_ERROR);
      return FALSE;
    }

    // Generate username if needed
    $username = openid_connect_generate_username($sub, $userinfo, $client_name);
    watchdog('openid_connect', 'Generated username: %username', array('%username' => $username), WATCHDOG_DEBUG);
    
    // Check if username already exists
    $existing_name = db_select('users', 'u')
      ->fields('u', array('uid', 'name'))
      ->condition('name', $username)
      ->execute()
      ->fetchObject();
      
    if ($existing_name) {
      watchdog('openid_connect', 'Username %username already exists (uid: %uid)', 
        array('%username' => $username, '%uid' => $existing_name->uid), WATCHDOG_ERROR);
      return FALSE;
    }
    
    // Create base user fields array with minimal required fields
    $fields = array(
      'name' => $username,
      'pass' => user_password(),
      'mail' => $userinfo['email'],
      'init' => $userinfo['email'],
      'status' => 1,
      'timezone' => config_get('system.date', 'default_timezone'),
      'roles' => array(BACKDROP_AUTHENTICATED_ROLE => BACKDROP_AUTHENTICATED_ROLE),
      'created' => REQUEST_TIME,
      'access' => REQUEST_TIME,
    );

    // Get field mappings from configuration
    $config = config('openid_connect.settings');
  
    // Get all field instances for user entity
    $instances = field_info_instances('user', 'user');
    
    // Map claims to fields based on configuration
    foreach ($instances as $field_name => $instance) {
      
      // checks the config of mappings set by site admin
      $claim = $config->get('openid_connect_userinfo_mapping_property_' . $field_name);
      if ($claim && isset($userinfo[$claim])) {
        $fields[$field_name][LANGUAGE_NONE][0]['value'] = $userinfo[$claim];
        watchdog('openid_connect', 'Mapped claim %claim to field %field with value: %value', 
          array(
            '%claim' => $claim,
            '%field' => $field_name,
            '%value' => $userinfo[$claim]
          ), WATCHDOG_DEBUG);
      }
    }

    // Add OpenID Connect specific data
    if (!isset($fields['data'])) {
      $fields['data'] = array();
    }
    $fields['data']['openid_connect_client'] = $client_name;
    $fields['data']['openid_connect_sub'] = $sub;
    
    // Log the fields array before user creation
    watchdog('openid_connect', 'Attempting to create user with fields: @fields', 
      array('@fields' => print_r($fields, TRUE)), WATCHDOG_DEBUG);

    // Create a new user account
    watchdog('openid_connect', 'Creating user entity...', array(), WATCHDOG_DEBUG);
    $account = entity_create('user', $fields);
    
    if (!$account) {
      watchdog('openid_connect', 'Failed to create user entity', array(), WATCHDOG_ERROR);
      return FALSE;
    }
    
    watchdog('openid_connect', 'User entity created, pre-save state: @account', 
      array('@account' => print_r($account, TRUE)), WATCHDOG_DEBUG);

    // Save the new user account
    watchdog('openid_connect', 'Attempting to save user...', array(), WATCHDOG_DEBUG);
    $save_result = user_save($account);
    
    watchdog('openid_connect', 'user_save() result: @result', 
      array('@result' => print_r($save_result, TRUE)), WATCHDOG_DEBUG);
    
    // Handle the case where user_save returns 1 (success) instead of the account object
    if ($save_result === 1) {
      watchdog('openid_connect', 'user_save() returned 1, loading user by name', array(), WATCHDOG_DEBUG);
      
      // Load the user by username since we know it's unique
      $saved_account = db_select('users', 'u')
        ->fields('u', array('uid'))
        ->condition('name', $username)
        ->execute()
        ->fetchObject();
        
      if (!$saved_account) {
        watchdog('openid_connect', 'Could not find newly created user by username: %name', 
          array('%name' => $username), WATCHDOG_ERROR);
        return FALSE;
      }
      
      watchdog('openid_connect', 'Found user in database with uid: %uid', 
        array('%uid' => $saved_account->uid), WATCHDOG_DEBUG);
        
        $saved_account = user_load($saved_account->uid);
    } else {
      $saved_account = $save_result;
    }
    
    // Verify the saved account
    if (!$saved_account) {
      watchdog('openid_connect', 'Failed to load saved account', array(), WATCHDOG_ERROR);
      return FALSE;
    }
    
    if (!isset($saved_account->uid) || empty($saved_account->uid)) {
      watchdog('openid_connect', 'Saved account has no valid UID. Account: @account', 
        array('@account' => print_r($saved_account, TRUE)), WATCHDOG_ERROR);
      return FALSE;
    }

    // Double check the user exists in the database
    $check_user = db_select('users', 'u')
      ->fields('u', array('uid', 'name', 'mail'))
      ->condition('uid', $saved_account->uid)
      ->execute()
      ->fetchObject();
      
    if (!$check_user) {
      watchdog('openid_connect', 'User not found in database after save. UID: %uid', 
        array('%uid' => $saved_account->uid), WATCHDOG_ERROR);
      return FALSE;
    }
    
    watchdog('openid_connect', 'Database verification successful. User record: @user', 
      array('@user' => print_r($check_user, TRUE)), WATCHDOG_DEBUG);

    // Load the full user object to ensure we have all properties
    $full_account = user_load($saved_account->uid);
    if (!$full_account) {
      watchdog('openid_connect', 'Failed to load newly created user %uid', 
        array('%uid' => $saved_account->uid), WATCHDOG_ERROR);
      return FALSE;
    }

    watchdog('openid_connect', 'Successfully created and loaded user account: @account', 
      array('@account' => print_r($full_account, TRUE)), WATCHDOG_DEBUG);

    return $full_account;

  } catch (Exception $e) {
    watchdog('openid_connect', 'Error creating user account: @message', 
      array('@message' => $e->getMessage()), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Generate a username for a new account.
 *
 * @param array $userinfo
 *   The user claims.
 *
 * @return string
 *   A unique username.
 */
function openid_connect_generate_username($sub, $userinfo, $client_name) {
  watchdog('openid_connect', 'Generating username in openid_connect_generate_username for sub: %sub', array('%sub' => $sub), WATCHDOG_DEBUG);
  $name = 'oidc_' . $client_name . '_' . $sub;
  $candidates = array('preferred_username', 'name');
  foreach ($candidates as $candidate) {
    if (!empty($userinfo[$candidate])) {
      $name = $userinfo[$candidate];
      watchdog('openid_connect', 'Using %candidate for username: %name', 
        array('%candidate' => $candidate, '%name' => $name), WATCHDOG_DEBUG);
      break;
    }
  }

  backdrop_alter('openid_connect_new_username', $name, $userinfo, $client_name);
  $sanitized_name = openid_connect_sanitize_new_username($name);
  watchdog('openid_connect', 'Generated sanitized username: %name', array('%name' => $sanitized_name), WATCHDOG_DEBUG);
  return $sanitized_name;
}

/**
 * Sanitize a username for a new account. The account must not be saved already.
 *
 * @param string $name
 *   The new account's proposed username.
 *
 * @return string
 *   The sanitized username.
 */
function openid_connect_sanitize_new_username($name) {
  watchdog('openid_connect', 'Sanitizing username in openid_connect_sanitize_new_username: %name', array('%name' => $name), WATCHDOG_DEBUG);
  $name = preg_replace('/ +/', ' ', trim($name));
  $illegal1 = '/[^\x{80}-\x{F7} a-z0-9@_.\'-]/i';
  $illegal2 = '/[\x{80}-\x{A0}'
    . '\x{AD}'
    . '\x{2000}-\x{200F}'
    . '\x{2028}-\x{202F}'
    . '\x{205F}-\x{206F}'
    . '\x{FEFF}'
    . '\x{FF01}-\x{FF60}'
    . '\x{FFF9}-\x{FFFD}'
    . '\x{0}-\x{1F}]'
    . '/u';
  $name = preg_replace($illegal1, '-', $name);
  $name = preg_replace($illegal2, '-', $name);
  $name = truncate_utf8($name, USERNAME_MAX_LENGTH, TRUE, FALSE, 20);

  for ($original = $name, $i = 1; openid_connect_username_exists($name); $i++) {
    $suffix = '_' . $i;
    $name = truncate_utf8($original, USERNAME_MAX_LENGTH - strlen($suffix)) . $suffix;
    watchdog('openid_connect', 'Username exists, trying with suffix: %name', array('%name' => $name), WATCHDOG_DEBUG);
  }
  watchdog('openid_connect', 'Final sanitized username: %name', array('%name' => $name), WATCHDOG_DEBUG);
  return $name;
}

/**
 * Check if a user name already exists.
 *
 * @param string $name
 *   A name to test.
 *
 * @return bool
 *   TRUE if a user exists with the given name, FALSE otherwise.
 */
function openid_connect_username_exists($name) {
  $exists = db_query('SELECT COUNT(*) FROM {users} WHERE name = :name', array(
    ':name' => $name,
  ))->fetchField() > 0;
  watchdog('openid_connect', 'Checking if username exists: %name - %exists', 
    array('%name' => $name, '%exists' => $exists ? 'yes' : 'no'), WATCHDOG_DEBUG);
  return $exists;
}

/**
 * Implements hook_username_alter().
 */
function openid_connect_username_alter($name, $account) {
  watchdog('openid_connect', 'Altering username in openid_connect_username_alter: %name', array('%name' => $name), WATCHDOG_DEBUG);
  if (!empty($account->data['oidc_name']) && (strpos($name, 'oidc_') === 0 || strpos($name, '@'))) {
    $name = $account->data['oidc_name'];
    watchdog('openid_connect', 'Using OIDC name instead: %name', array('%name' => $name), WATCHDOG_DEBUG);
  }
  return $name;
}

/**
 * Implements hook_user_insert().
 */
function openid_connect_user_insert($edit, $account = NULL, $category = NULL) {
  if (isset($account->openid_connect_client)) {
    watchdog('openid_connect', 'Connecting user %uid to OpenID Connect client %client with sub %sub', 
      array(
        '%uid' => $account->uid,
        '%client' => $account->openid_connect_client,
        '%sub' => $account->openid_connect_sub
      ), 
      WATCHDOG_DEBUG
    );
    openid_connect_connect_account($account, $account->openid_connect_client, $account->openid_connect_sub);
  }
}

/**
 * Deletes a user's authmap entries.
 */
function openid_connect_authmap_delete($uid) {
  db_delete('authmap')
    ->condition('uid', $uid)
    ->condition('module', db_like('openid_connect_') . '%', 'LIKE')
    ->execute();
}

/**
 * Implements hook_user_delete().
 */
function openid_connect_user_delete($account) {
  openid_connect_authmap_delete($account->uid);
}

/**
 * Implements hook_user_cancel().
 */
function openid_connect_user_cancel($edit, $account, $method) {
  openid_connect_authmap_delete($account->uid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function openid_connect_form_user_profile_form_alter($form, $form_state) {
  if (isset($form['account'])) {
    $account_form = $form['account'];
  }
  else {
    $account_form = $form;
  }

  // Do nothing if the user does not have access to password field.


  if (isset($account_form['pass']['#access'])
        && !$account_form['pass']['#access']) {
    return;
  }

  if (!openid_connect_set_password_access($form['#user'])) {
    $account_form['current_pass']['#access'] = FALSE;
    $account_form['current_pass_required_values']['#value'] = array();
    $account_form['pass']['#access'] = FALSE;
  }
}

/**
 * Find whether the user is allowed to change their own password.
 *
 * @param object $account
 *   A user account object.
 *
 * @return bool
 *   TRUE if access is granted, FALSE otherwise.
 */
function openid_connect_set_password_access($account) {
  if (user_access('openid_connect set own password', $account)) {
    return TRUE;
  }

  $connected_accounts = openid_connect_get_connected_accounts($account);

  return empty($connected_accounts);
}

/**
 * Loads a user based on a sub-id and a login provider.
 */
function openid_connect_user_load_by_sub($sub, $client_name) {
  watchdog('openid_connect', 'Loading user by sub in openid_connect_user_load_by_sub: %sub', array('%sub' => $sub), WATCHDOG_DEBUG);
  $result = db_select('authmap', 'a')
    ->fields('a', array('uid', 'module'))
    ->condition('authname', $sub)
    ->condition('module', 'openid_connect_' . $client_name)
    ->execute()
    ->fetchAssoc();
  
  if ($result) {
    $account = user_load($result['uid']);
    if (is_object($account)) {
      watchdog('openid_connect', 'Found user with uid: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
      watchdog('openid_connect', 'Account details after loading by sub: @account', array('@account' => print_r($account, TRUE)), WATCHDOG_DEBUG);
      return $account;
    }
  }
  watchdog('openid_connect', 'No user found for sub: %sub', array('%sub' => $sub), WATCHDOG_DEBUG);
  return FALSE;
}

/**
 * Returns OpenID Connect claims.
 *
 * This defines the standard claims, and allows them to be extended via an
 * alter hook.
 *
 * @see http://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
 * @see http://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims
 *
 * @return array
 *   Set of standard claims.
 */
function openid_connect_claims() {
  $claims = array(
    'name' => array(
      'scope' => 'profile',
    ),
    'middle_name' => array(
      'scope' => 'profile',
    ),
    'nickname' => array(
      'scope' => 'profile',
    ),
    'preferred_username' => array(
      'scope' => 'profile',
    ),
    'profile' => array(
      'scope' => 'profile',
    ),
    'picture' => array(
      'scope' => 'profile',
    ),
    'website' => array(
      'scope' => 'profile',
    ),
    'gender' => array(
      'scope' => 'profile',
    ),
    'birthdate' => array(
      'scope' => 'profile',
    ),
    'zoneinfo' => array(
      'scope' => 'profile',
    ),
    'locale' => array(
      'scope' => 'profile',
    ),
    'updated_at' => array(
      'scope' => 'profile',
    ),
    'email' => array(
      'scope' => 'email',
    ),
    'email_verified' => array(
      'scope' => 'email',
    ),
    'address' => array(
      'scope' => 'address',
    ),
    'phone_number' => array(
      'scope' => 'phone',
    ),
    'phone_number_verified' => array(
      'scope' => 'phone',
    ),
  );
  backdrop_alter(__FUNCTION__, $claims);
  return $claims;
}

/**
 * Returns OpenID Connect standard Claims as a Form API options array.
 */
function openid_connect_claims_options() {
  $options = array();
  foreach (openid_connect_claims() as $claim_name => $claim) {
    $options[$claim['scope']][$claim_name] = $claim_name;
  }
  return $options;
}

/**
 * Returns scopes that have to be requested based on the configured claims.
 *
 * @see http://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims
 *
 * @return string
 *   Space delimited case sensitive list of ASCII scope values.
 */
function openid_connect_get_scopes() {
  $claims = config_get('openid_connect.settings', 'openid_connect_userinfo_mapping_claims');
  $scopes = array('openid', 'email', 'profile', 'address');
  $claims_info = openid_connect_claims();
  foreach ($claims as $claim) {
    if (isset($claims_info[$claim]) && !isset($scopes[$claims_info[$claim]['scope']]) && $claim != 'email') {
      $scopes[$claims_info[$claim]['scope']] = $claims_info[$claim]['scope'];
    }
  }

  $final_scopes = implode(' ', $scopes);
  watchdog('openid_connect', 'Requesting OIDC scopes: %scopes', array('%scopes' => $final_scopes), WATCHDOG_DEBUG);
  return $final_scopes;
}

/**
 * Returns user properties that can be skipped when mapping user profile info.
 */
function _openid_connect_user_properties_to_skip() {
  $properties_to_skip = array(
    'uid',
    'url',
    'edit_url',
    'last_access',
    'last_login',
    'created',
    'roles',
    'status',
    'theme',
  );
  return backdrop_map_assoc($properties_to_skip);
}

/**
 * Logs an error occured during a request towards a login provider.
 */
function openid_connect_log_request_error($method, $client_name, $response) {
  switch ($method) {
    case 'retrieveTokens':
      $message = 'Could not retrieve tokens (@code @error). Details: @details';
      break;

    case 'retrieveUserInfo':
      $message = 'Could not retrieve user profile information (@code @error). Details: @details';
      break;

    default:
      return;
  }

  // Some error responses don't have a data key set.


  $details = '';
  if (!empty($response->data)) {
    $details = print_r(backdrop_json_decode($response->data), TRUE);
  }
  $variables = array(
    '@error' => $response->error,
    '@code' => $response->code,
    '@details' => $details,
  );
  watchdog('openid_connect_' . $client_name, $message, $variables, WATCHDOG_ERROR);
}

/**
 * Implements hook_entity_property_info_alter().
 *
 * Adds the missing timezone property.
 */
function openid_connect_entity_property_info_alter($info) {
  $properties = $info['user']['properties'];
  if (!isset($properties['timezone'])) {
    $properties['timezone'] = array(
      'label' => t('Time zone'),
      'description' => t("The user's time zone."),
      'options list' => 'system_time_zones',
      'getter callback' => 'entity_property_verbatim_get',
      'setter callback' => 'entity_property_verbatim_set',
      'schema field' => 'timezone',
    );
  }
}

/**
 * Get a list of external OIDC accounts connected to this Backdrop account.
 *
 * @param object $account
 *   A Backdrop user entity.
 *
 * @return array
 *   An array of 'sub' properties keyed by the client name.
 */
function openid_connect_get_connected_accounts($account) {
  $auth_maps = db_query(
    "SELECT module, authname FROM {authmap} WHERE uid = :uid AND module LIKE 'openid_connect_%'",
    array(':uid' => $account->uid)
  );
  $module_offset = strlen('openid_connect_');
  $results = array();
  foreach ($auth_maps as $auth_map) {
    $client = substr($auth_map->module, $module_offset);
    $sub = $auth_map->authname;
    $results[$client] = $sub;
  }

  return $results;
}

/**
 * Connect an external OpenID Connect account to a Backdrop user account.
 *
 * @param object $account
 *   The Backdrop user object.
 * @param string $client_name
 *   The client machine name.
 * @param string $sub
 *   The 'sub' property identifying the external account.
 */
function openid_connect_connect_account($account, $client_name, $sub) {
  $timestamp = microtime(TRUE);
  watchdog('openid_connect', '[%time] Starting account connection process', 
    array('%time' => $timestamp), WATCHDOG_DEBUG);
  watchdog('openid_connect', '[%time] Connection details - uid: %uid, client: %client, sub: %sub', 
    array(
      '%time' => $timestamp,
      '%uid' => $account->uid,
      '%client' => $client_name,
      '%sub' => $sub
    ), WATCHDOG_DEBUG);
  
  // First, remove any existing authmap entries for this client
  $timestamp = microtime(TRUE);
  watchdog('openid_connect', '[%time] Removing existing authmap entries', array('%time' => $timestamp), WATCHDOG_DEBUG);
  $delete_result = db_delete('authmap')
    ->condition('uid', $account->uid)
    ->condition('module', 'openid_connect_' . $client_name)
    ->execute();
  watchdog('openid_connect', '[%time] Delete operation result: %result', 
    array('%time' => $timestamp, '%result' => $delete_result), WATCHDOG_DEBUG);
    
  // Then insert the new authmap entry
  $timestamp = microtime(TRUE);
  watchdog('openid_connect', '[%time] Attempting to insert new authmap entry', array('%time' => $timestamp), WATCHDOG_DEBUG);
  try {
    $insert_result = db_insert('authmap')
      ->fields(array(
        'uid' => $account->uid,
        'module' => 'openid_connect_' . $client_name,
        'authname' => $sub,
      ))
      ->execute();
    watchdog('openid_connect', '[%time] Insert operation result: %result', 
      array('%time' => $timestamp, '%result' => $insert_result), WATCHDOG_DEBUG);
    
    // Verify the connection was successful
    $timestamp = microtime(TRUE);
    watchdog('openid_connect', '[%time] Verifying connection in database', array('%time' => $timestamp), WATCHDOG_DEBUG);
    $verify_result = db_select('authmap', 'a')
      ->fields('a', array('uid', 'module', 'authname'))
      ->condition('uid', $account->uid)
      ->condition('module', 'openid_connect_' . $client_name)
      ->condition('authname', $sub)
      ->execute()
      ->fetchAssoc();
      
    if ($verify_result) {
      watchdog('openid_connect', '[%time] Connection verified successfully: @result', 
        array('%time' => $timestamp, '@result' => print_r($verify_result, TRUE)), WATCHDOG_DEBUG);
      return TRUE;
    } else {
      watchdog('openid_connect', '[%time] Connection verification failed - no matching record found', 
        array('%time' => $timestamp), WATCHDOG_ERROR);
      return FALSE;
    }
  }
  catch (Exception $e) {
    watchdog('openid_connect', '[%time] Exception during connection: @error', 
      array('%time' => $timestamp, '@error' => $e->getMessage()), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Disconnect an external OpenID Connect account from a Backdrop user account.
 *
 * @param object $account
 *   The Backdrop user object.
 * @param string $client_name
 *   The client machine name.
 * @param string $sub
 *   The 'sub' property identifying the external account (optional).
 */
function openid_connect_disconnect_account($account, $client_name, $sub = NULL) {
  watchdog('openid_connect', 'Disconnecting account in openid_connect_disconnect_account: uid=%uid, client=%client', 
    array('%uid' => $account->uid, '%client' => $client_name), WATCHDOG_DEBUG);
  $query = db_delete('authmap');
  $query->condition('uid', $account->uid)
    ->condition('module', 'openid_connect_' . $client_name);
  if ($sub !== NULL) {
    $query->condition('authname', $sub);
  }
  $query->execute();
  watchdog('openid_connect', 'Successfully disconnected account', array(), WATCHDOG_DEBUG);
}

/**
 * Get the 'sub' property from the user data and/or user claims.
 *
 * The 'sub' (Subject Identifier) is a unique ID for the external provider to
 * identify the user.
 *
 * @param array $user_data
 *   The user data as returned from
 *   OpenIDConnectClientInterface::decodeIdToken().
 * @param array $userinfo
 *   The user claims as returned from
 *   OpenIDConnectClientInterface::retrieveUserInfo().
 *
 * @return string|false
 *   The sub, or FALSE if there was an error.
 */
function openid_connect_extract_sub($user_data, $userinfo) {
  watchdog('openid_connect', 'Extracting sub in openid_connect_extract_sub', array(), WATCHDOG_DEBUG);
  if (!isset($user_data['sub']) && !isset($userinfo['sub'])) {
    watchdog('openid_connect', 'No sub found in either user_data or userinfo', array(), WATCHDOG_DEBUG);
    return FALSE;
  }
  elseif (!isset($user_data['sub'])) {
    watchdog('openid_connect', 'Using sub from userinfo: %sub', array('%sub' => $userinfo['sub']), WATCHDOG_DEBUG);
    return $userinfo['sub'];
  }
  elseif (isset($userinfo['sub']) && $user_data['sub'] != $userinfo['sub']) {
    watchdog('openid_connect', 'Sub mismatch between user_data and userinfo', array(), WATCHDOG_DEBUG);
    return FALSE;
  }
  else {
    watchdog('openid_connect', 'Using sub from user_data: %sub', array('%sub' => $user_data['sub']), WATCHDOG_DEBUG);
    return $user_data['sub'];
  }
}

/**
 * Complete the authorization after tokens have been retrieved.
 *
 * @param OpenIDConnectClientInterface $client
 *   The client.
 * @param array $tokens
 *   The tokens as returned from OpenIDConnectClientInterface::retrieveTokens().
 * @param string|array &$destination
 *   The path to redirect to after authorization.
 *
 * @return bool
 *   TRUE on success, FALSE on failure.
 */
function openid_connect_complete_authorization($client, $tokens, $destination) {
  watchdog('openid_connect', 'Starting authorization in openid_connect_complete_authorization', array(), WATCHDOG_DEBUG);
  $config = config('openid_connect.settings');
  if (user_is_logged_in()) {
    watchdog('openid_connect', 'User already logged in, throwing exception', array(), WATCHDOG_DEBUG);
    throw new Exception('User already logged in');
  }

  // Validate tokens array
  if (!is_array($tokens) || empty($tokens['id_token']) || empty($tokens['access_token'])) {
    watchdog('openid_connect', 'Invalid or missing tokens in authorization', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  $user_data = $client->decodeIdToken($tokens['id_token']);
  $userinfo = $client->retrieveUserInfo($tokens['access_token']);
  
  // Log complete userinfo response
  watchdog('openid_connect', 'Complete userinfo response from server: @userinfo', 
    array('@userinfo' => print_r($userinfo, TRUE)), 
    WATCHDOG_DEBUG
  );
  
  // Specifically log address-related fields
  if (isset($userinfo['address'])) {
    watchdog('openid_connect', 'Address data received: @address', 
      array('@address' => print_r($userinfo['address'], TRUE)), 
      WATCHDOG_DEBUG
    );
  }
  if (isset($userinfo['address']['region'])) {
    watchdog('openid_connect', 'State received: %state', 
      array('%state' => $userinfo['address']['region']), 
      WATCHDOG_DEBUG
    );
  }
  if (isset($userinfo['address']['country'])) {
    watchdog('openid_connect', 'Country received: %country', 
      array('%country' => $userinfo['address']['country']), 
      WATCHDOG_DEBUG
    );
  }

  if (empty($userinfo['email'])) {
    watchdog('openid_connect', 'No e-mail address provided by @provider', array('@provider' => $client->getLabel()), WATCHDOG_ERROR);
    return FALSE;
  }

  $sub = openid_connect_extract_sub($user_data, $userinfo);
  if (empty($sub)) {
    watchdog('openid_connect', 'No "sub" found from @provider', array('@provider' => $client->getLabel()), WATCHDOG_ERROR);
    return FALSE;
  }

  // Check whether the e-mail address is valid.
  if (!filter_var($userinfo['email'], FILTER_VALIDATE_EMAIL)) {
    watchdog('openid_connect', 'Invalid email address in openid_connect_complete_authorization: %mail', array('%mail' => $userinfo['email']), WATCHDOG_DEBUG);
    backdrop_set_message(t('The e-mail address %mail is not valid.', array('%mail' => $userinfo['email'])), 'error');
    return FALSE;
  }

  $account = openid_connect_user_load_by_sub($sub, $client->getName());
  watchdog('openid_connect', 'Loaded account by sub in openid_connect_complete_authorization: %uid', array('%uid' => $account ? $account->uid : 'not found'), WATCHDOG_DEBUG);
  watchdog('openid_connect', 'Account details after loading by sub: @account', array('@account' => print_r($account, TRUE)), WATCHDOG_DEBUG);
  
  $results = module_invoke_all('openid_connect_pre_authorize', $tokens, $account, $userinfo, $client->getName());

  // Deny access if any module returns FALSE.
  if (in_array(FALSE, $results, TRUE)) {
    watchdog('openid_connect', 'Login denied for @email via pre-authorize hook.', array('@email' => $userinfo['email']), WATCHDOG_ERROR);
    return FALSE;
  }

  if ($account) {
    // An existing account was found. Save user claims.
    watchdog('openid_connect', 'Existing account found in openid_connect_complete_authorization: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
    $account_is_new = FALSE;
  }
  elseif ($account = user_load_by_mail($userinfo['email'])) {
    // Check whether there is an e-mail address conflict.
    watchdog('openid_connect', 'Account found by email in openid_connect_complete_authorization: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
    watchdog('openid_connect', 'Account details after loading by email: @account', array('@account' => print_r($account, TRUE)), WATCHDOG_DEBUG);
    if ($config->get('openid_connect_connect_existing_users')) {
      $result = openid_connect_connect_account($account, $client->getName(), $sub);
      if (!$result) {
        watchdog('openid_connect', 'Failed to connect existing account', array(), WATCHDOG_ERROR);
        return FALSE;
      }
      $account_is_new = FALSE;
    }
    else {
      backdrop_set_message(t('The e-mail address %email is already taken.', array('%email' => $userinfo['email'])), 'error');
      return FALSE;
    }
  }
  else {
    // Create a new account.
    watchdog('openid_connect', 'Creating new account in openid_connect_complete_authorization', array(), WATCHDOG_DEBUG);
    $account = openid_connect_create_user($sub, $userinfo, $client->getName());
    if (!$account) {
      watchdog('openid_connect', 'Failed to create new account', array(), WATCHDOG_ERROR);
      return FALSE;
    }
    
    // Connect the new account
    $result = openid_connect_connect_account($account, $client->getName(), $sub);
    if (!$result) {
      watchdog('openid_connect', 'Failed to connect new account', array(), WATCHDOG_ERROR);
      return FALSE;
    }
    
    // Reload the account to ensure we have all properties
    $account = user_load($account->uid);
    if (!$account) {
      watchdog('openid_connect', 'Failed to load newly created user', array(), WATCHDOG_ERROR);
      return FALSE;
    }
    
    $account_is_new = TRUE;
  }

  // save userinfo into account for future
  if ($config->get('openid_connect_always_save_userinfo')) {
    openid_connect_save_userinfo($account, $userinfo);
  }

  watchdog('openid_connect', 'Logging in user in openid_connect_complete_authorization: %uid', array('%uid' => $account->uid), WATCHDOG_DEBUG);
  
  // Initialize the user's session
  global $user;
  $loaded_user = user_load($account->uid);
  if (!$loaded_user) {
    watchdog('openid_connect', 'Failed to load user for login: %uid', array('%uid' => $account->uid), WATCHDOG_ERROR);
    return FALSE;
  }
  watchdog('openid_connect', 'Loaded user for login: @user', array('@user' => print_r($loaded_user, TRUE)), WATCHDOG_DEBUG);
  
  // Start session if needed
  if (!backdrop_session_started()) {
    backdrop_session_start();
    watchdog('openid_connect', 'Started new session for login', array(), WATCHDOG_DEBUG);
  }
  
  // Set the global user object first
  $user = $loaded_user;
  $GLOBALS['user'] = $loaded_user;
  
  watchdog('openid_connect', 'Global user set to: @user', array('@user' => print_r($GLOBALS['user'], TRUE)), WATCHDOG_DEBUG);
  
  // Ensure all required properties are set
  if (!isset($user->timezone)) {
    $user->timezone = config_get('system.date', 'default_timezone');
  }
  
  // Initialize the session before finalization
  $_SESSION['uid'] = $user->uid;
  $_SESSION['roles'] = array_keys($user->roles);
  $_SESSION['name'] = $user->name;
  
  watchdog('openid_connect', 'Session data before finalize: @session', array('@session' => print_r($_SESSION, TRUE)), WATCHDOG_DEBUG);
  
  // Finalize the login which will properly set up the session
  $edit = array();
  user_login_finalize($edit);
  
  // Double check session data
  watchdog('openid_connect', 'Session data after finalize: @session', array('@session' => print_r($_SESSION, TRUE)), WATCHDOG_DEBUG);
  
  // Update the user's last login time
  $user->login = REQUEST_TIME;
  user_save($user);
  
  watchdog('openid_connect', 'Login completed - Current user: @user', array('@user' => print_r($GLOBALS['user'], TRUE)), WATCHDOG_DEBUG);
  
  // Check if user is logged in
  $is_logged_in = user_is_logged_in();
  watchdog('openid_connect', 'User login status after login attempt: %status', array('%status' => $is_logged_in ? 'logged in' : 'not logged in'), WATCHDOG_DEBUG);
  
  if (!$is_logged_in) {
    watchdog('openid_connect', 'Failed to log in user after successful authorization. Current user: @user', 
      array('@user' => print_r($GLOBALS['user'], TRUE)), WATCHDOG_ERROR);
    return FALSE;
  }

  module_invoke_all('openid_connect_post_authorize', $tokens, $account, $userinfo, $client->getName(), $account_is_new);
  watchdog('openid_connect', 'Completed authorization in openid_connect_complete_authorization', array(), WATCHDOG_DEBUG);

  return TRUE;
}

/**
 * Connect the current user's account to an external provider.
 *
 * @param OpenIDConnectClientInterface $client
 *   The client.
 * @param array $tokens
 *   The tokens as returned from OpenIDConnectClientInterface::retrieveTokens().
 *
 * @return bool
 *   TRUE on success, FALSE on failure.
 */
function openid_connect_connect_current_user($client, $tokens) {
  watchdog('openid_connect', 'Starting connection in openid_connect_connect_current_user', array(), WATCHDOG_DEBUG);
  global $user;
  if (!$user->uid) {
    watchdog('openid_connect', 'User not logged in in openid_connect_connect_current_user', array(), WATCHDOG_DEBUG);
    throw new Exception('User not logged in');
  }

  $user_data = $client->decodeIdToken($tokens['id_token']);
  $userinfo = $client->retrieveUserInfo($tokens['access_token']);
  watchdog('openid_connect', 'Retrieved user data and userinfo in openid_connect_connect_current_user', array(), WATCHDOG_DEBUG);

  $provider_param = array('@provider' => $client->getLabel());

  if (empty($userinfo['email'])) {
    watchdog('openid_connect', 'No e-mail address provided by @provider', $provider_param, WATCHDOG_ERROR);
    return FALSE;
  }

  $sub = openid_connect_extract_sub($user_data, $userinfo);
  if (empty($sub)) {
    watchdog('openid_connect', 'No "sub" found from @provider', $provider_param, WATCHDOG_ERROR);
    return FALSE;
  }

  $account = openid_connect_user_load_by_sub($sub, $client->getName());
  watchdog('openid_connect', 'Loaded account by sub in openid_connect_connect_current_user: %uid', array('%uid' => $account ? $account->uid : 'not found'), WATCHDOG_DEBUG);
  
  $results = module_invoke_all('openid_connect_pre_authorize', $tokens, $account, $userinfo, $client->getName());
  watchdog('openid_connect', 'Pre-authorize hook results in openid_connect_connect_current_user: %results', array('%results' => print_r($results, TRUE)), WATCHDOG_DEBUG);

  // Deny access if any module returns FALSE.
  if (in_array(FALSE, $results, TRUE)) {
    watchdog('openid_connect', 'Login denied for @email via pre-authorize hook.', array('@email' => $userinfo['email']), WATCHDOG_ERROR);
    return FALSE;
  }

  if ($account && $account->uid !== $user->uid) {
    watchdog('openid_connect', 'Another user already connected in openid_connect_connect_current_user', array(), WATCHDOG_DEBUG);
    backdrop_set_message(t('Another user is already connected to this @provider account.', $provider_param), 'error');
    return FALSE;
  }

  if (!$account) {
    watchdog('openid_connect', 'Connecting new account in openid_connect_connect_current_user: %uid', array('%uid' => $user->uid), WATCHDOG_DEBUG);
    $account = $user;
    openid_connect_connect_account($account, $client->getName(), $sub);
  }

  if (config_get('openid_connect.settings', 'openid_connect_always_save_userinfo')) {
    openid_connect_save_userinfo($account, $userinfo);
  }

  module_invoke_all('openid_connect_post_authorize', $tokens, $account, $userinfo, $client->getName(), FALSE);
  watchdog('openid_connect', 'Completed connection in openid_connect_connect_current_user', array(), WATCHDOG_DEBUG);

  return TRUE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function openid_connect_form_user_pass_alter(array $form,    $form_state) {
  $form['#validate'][] = '_openid_connect_user_pass_form_validate';
}

/**
 * Custom validation for the password reset form.
 */
function _openid_connect_user_pass_form_validate(array $form,    $form_state) {
  // If the account doesn't exist, return early.


  if (empty($form_state['values']['account'])) {
    return;
  }

  $account = $form_state['values']['account'];

  $results = openid_connect_get_connected_accounts($account);

  // If not in the authmap table, return early.


  if (empty($results)) {
    return;
  }

  // If the user has permission to manage their local password, allow it.


  if (user_access('openid_connect set own password', $account)) {
    return;
  }

  form_set_error('name', t('%name is connected to an external authentication system.', array(
    '%name' => $form_state['values']['name'],
  )));
}

/**
 * Implements hook_autoload_info().
 */
function openid_connect_autoload_info() {
  $info = array(
    'OpenIDConnectClientBase' => 'includes/OpenIDConnectClientBase.class.php',
    'OpenIDConnectClientInterface' => 'includes/OpenIDConnectClientInterface.class.php',
  );
  
  // Add client plugins
  $plugin_path = 'plugins/openid_connect_client';
  $module_path = backdrop_get_path('module', 'openid_connect');
  if (is_dir($module_path . '/' . $plugin_path)) {
    $dirs = scandir($module_path . '/' . $plugin_path);
    foreach ($dirs as $dir) {
      if ($dir[0] != '.' && is_dir($module_path . '/' . $plugin_path . '/' . $dir)) {
        $client_name = $dir;
        $class_name = 'OpenIDConnectClient' . backdrop_ucfirst($client_name);
        $class_file = $plugin_path . '/' . $client_name . '/' . $class_name . '.class.php';
        if (file_exists($module_path . '/' . $class_file)) {
          $info[$class_name] = $class_file;
        }
      }
    }
  }
  
  return $info;
}
